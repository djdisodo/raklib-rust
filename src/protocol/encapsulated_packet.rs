use binaryutils::binary_stream::BinaryStream;
use binaryutils::binary::{read_unsigned_int, Endian, write_unsigned_short, write_unsigned_triad, write_unsigned_int};
use crate::protocol::packet_reliability::PacketReliability;
use binaryutils::binary::Endian::{Big, Little};
use std::ops::Div;
use std::borrow::Borrow;

struct EncapsulatedPacket {
	/* i don't know what size should it be */
	pub reliability : u8,
	pub has_split : bool,
	pub length : usize,
	pub message_index : Option<u32/* Triad */>,
	pub sequence_index : Option<u32/* Triad */>,
	pub order_index : Option<u32/* Triad */>,
	pub order_channel : Option<u8>,
	pub split_count : Option<u32>,
	pub split_id : Option<u16>,
	pub split_index : Option<u32>,
	pub buffer : Vec<u8>,
	pub need_ack : bool,
	pub identifier_ack : Option<u32>
}

impl EncapsulatedPacket {
	const RELIABILITY_SHIFT : u8 = 0x05;
	const RELIABILITY_FLAGS : u8 = 0b111 << Self::RELIABILITY_SHIFT;
	const SPLIT_FLAG : u8 = 0b00010000;
	pub fn new() -> EncapsulatedPacket {
		return EncapsulatedPacket {
			reliability: 0,
			has_split: false,
			length: 0,
			message_index: None,
			sequence_index: None,
			order_index: None,
			order_channel: None,
			split_count: None,
			split_id: None,
			split_index: None,
			buffer: Vec::new(),
			need_ack: false,
			identifier_ack: None
		};
	}
	pub fn get_total_length(&self) -> usize {
		return 3
			+ self.buffer.len()
			+ if self.message_index.is_some() { 3 } else { 0 }
			+ if self.order_index.is_some() { 3 } else { 0 }
			+ if self.has_split { 10 } else { 0 };
	}
}

impl From<Vec<u8>> for EncapsulatedPacket {
	fn from(mut bytes : Vec<u8>) -> Self {
		let mut packet : EncapsulatedPacket = EncapsulatedPacket::new();

		let mut offset : usize = 0;
		packet.reliability = bytes.get(offset).unwrap().clone();
		offset += 1;
		/* TODO: don't read this for non-ack-receipt reliabilities ******************** */
		let mut int_bytes : Vec<u8> = Vec::with_capacity(4);
		int_bytes.extend(bytes.drain(..offset));
		offset += 4;
		packet.identifier_ack = Some(read_unsigned_int(int_bytes, Endian::Big));
		/* TODO************************************************************************ */
		if PacketReliability::from(packet.reliability).is_sequence_or_ordered() {
			packet.order_channel = Some(bytes.get(offset).unwrap().clone());
			offset += 1;
		}
		packet.buffer = Vec::new();
		packet.buffer.extend(bytes.drain(..offset));
		return packet;
	}
}

impl From<BinaryStream> for EncapsulatedPacket {
	/**
	 * Decodes an EncapsulatedPacket from bytes generated by toInternalBinary().
	 */
	fn from(mut stream : BinaryStream) -> Self {
		let mut packet : EncapsulatedPacket = EncapsulatedPacket::new();

		let flags : u8 = stream.get_byte();
		packet.reliability = (flags & Self::SPLIT_FLAG) >> Self::RELIABILITY_SHIFT;
		let reliability : &u8 = &packet.reliability;
		packet.has_split = (flags & Self::SPLIT_FLAG) > 0;
		let has_split : &bool = &packet.has_split;

		let length : usize = (stream.get_short(Big) as f32).div(8.0) as usize;
		if length == 0 {
			panic!("Encapsulated payload length cannot be zero");
		}

		if reliability > &(PacketReliability::Unreliable as u8) {
			let reliability : PacketReliability = PacketReliability::from(reliability.clone());
			if reliability.is_reliable() {
				packet.message_index = Some(stream.get_unsigned_triad(Little));
			}

			if reliability.is_sequenced() {
				packet.sequence_index = Some(stream.get_unsigned_triad(Little));
			}

			if reliability.is_sequence_or_ordered() {
				packet.order_index = Some(stream.get_unsigned_triad(Little));
				packet.order_channel = Some(stream.get_byte());
			}
		}

		if *has_split {
			packet.split_count = Some(stream.get_unsigned_int(Big));
			packet.split_id = Some(stream.get_unsigned_short(Big));
			packet.split_index = Some(stream.get_unsigned_int(Big));
		}

		packet.buffer = stream.get(length);
		return packet;
	}
}

impl Into<Vec<u8>> for EncapsulatedPacket {
	fn into(self) -> Vec<u8> {
		let mut buffer : Vec<u8> = Vec::new();
		buffer.push((self.reliability << Self::RELIABILITY_SHIFT) | (if self.has_split { Self::SPLIT_FLAG } else { 0 }));
		buffer.extend(write_unsigned_short((self.buffer.len() as u16) << 3, Big));
		if self.reliability > PacketReliability::Unreliable as u8 {
			let reliability : PacketReliability = PacketReliability::from(self.reliability);
			if reliability.is_reliable() {
				buffer.extend(write_unsigned_triad(self.message_index.unwrap(), Little));
			}
			if reliability.is_sequenced() {
				buffer.extend(write_unsigned_triad(self.sequence_index.unwrap(), Little));
			}
			if reliability.is_sequence_or_ordered() {
				buffer.extend(write_unsigned_triad(self.order_index.unwrap(), Little));
				buffer.push(self.order_channel.unwrap());
			}
		}
		if self.has_split {
			buffer.extend(write_unsigned_int(self.split_count.unwrap(), Big));
			buffer.extend(write_unsigned_short(self.split_id.unwrap(), Big));
			buffer.extend(write_unsigned_int(self.split_index.unwrap(), Big));
		}
		buffer.extend(self.buffer);
		return buffer;
	}
}